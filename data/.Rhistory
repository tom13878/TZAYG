filter(any(zaocode %in% "maize") & length(zaocode) == length(unique(zaocode))) %>%
summarise(crop_count=length(zaocode)) # 3077 plots once a couple of duplicates have been removed.
# merge together the output, region and cropcodes and the price data. Need
# crop codes because zaocodes in the output data and the item_name in the price
# data are different
output_maize <- left_join( by_plot, output )
output_maize <- left_join( output_maize, regions )
output_maize <- left_join( output_maize, crop_codes )
output_maize <- left_join( output_maize, prices )
summary(output_maize)
head(output_maize[is.na(output_maizeregion_price),])
head(output_maize[is.na(output_maize$region_price),])
head(output_maize[is.na(output_maize$region_price),], 20)
prices[prices$region=="kilimanjaro",]
unique(prices$item_name)
rm(list=ls())
filepath <- 'W:/LEI/Internationaal Beleid  (IB)/Projecten/2285000066 Africa Maize Yield Gap/SurveyData/Tanzania/2012/Data'
setwd( filepath )
CQSECCF <- read.spss( "COM_SEC_CF.SAV", to.data.frame=TRUE )
# There are both village and district level prices
# rename variables to something that makes sense and select only what you want
# variables prefixed by vill refer to village market measurements. Variables
# prefixed by dis refer to district market measurements
prices <- select( CQSECCF, region=id_01, item_name, vill_unit=cm_f06meas,
vill_weight=cm_f06wght, vill_price=cm_f06pri, dis_unit = cm_f06meas2,
dis_weight=cm_f06wght2, dis_price=cm_f06pri2 )
# set some values to NA rather than zero, otherwise end up with strange values
# when converting units. Also it doesn't make sense when there is a weight but no
# price, or a price and no weight
prices$vill_weight[prices$vill_weight == 0] <- NA
prices$vill_price[prices$vill_price == 0] <- NA
prices$dis_weight[prices$dis_weight == 0] <- NA
prices$dis_price[prices$dis_price == 0] <- NA
# get unit prices - making sure to convert units into kilograms, i.e. price
# per kilogram.
prices$vill_price <- with( prices,
ifelse( vill_unit == "Grams", vill_price/( vill_weight/1000 ),
ifelse( vill_unit == "Kilograms", vill_price/( vill_weight ),
ifelse( vill_unit == "Litre", vill_price/( vill_weight ),
ifelse( vill_unit == "Millilitre", vill_price/( vill_weight/1000 ),
ifelse( vill_unit == "Pieces", vill_price/( vill_weight ),
vill_price/vill_weight ) ) ) ) ) )
prices$dis_price <- with( prices,
ifelse( dis_unit == "Grams", dis_price/( dis_weight/1000 ),
ifelse( dis_unit == "Kilograms", dis_price/( dis_weight ),
ifelse( dis_unit == "Litre", dis_price/( dis_weight ),
ifelse( dis_unit == "Millilitre", dis_price/( dis_weight/1000 ),
ifelse( dis_unit == "Pieces", dis_price/( dis_weight ),
dis_price/dis_weight ) ) ) ) ) )
# don't need original prices anymore, just local and district level unit prices
prices <- select( prices, region, item_name, vill_price, dis_price )
# test to see if each item is available for each region
test <- unique( select(prices, region, item_name) )
test_split <- split(test, test$region)
test_split_result <- sapply(test_split, function(elt) unique(test$item_name) %in% elt$item_name)
table(test_split_result)
# need to make sure there is a price observation for every item for every region
prices <- left_join( unique( select(prices, region, item_name) ), prices)
# a final thing. whoever imputed the data for year seriously does not understand
# white space. The item_name variable is all messed up. following code fixes this
x <- strsplit( as.character(prices$item_name) , "  " )
prices$item_name <- factor( sapply( x, function( elt ) return( elt[[1]] ) ) )
x <- select( prices, region, item_name )
summary(x)
summary(factor(x$region))
x <- unique(select( prices, region, item_name ))
summary(x$region)
summary(x$item_name)
write.csv( prices, "M:/TZAYG/data/2012/prices_w3.csv", row.names = FALSE )
rm(list=ls())
CQSECCF <- read.spss( "COM_SEC_CF.SAV", to.data.frame=TRUE )
# There are both village and district level prices
# rename variables to something that makes sense and select only what you want
# variables prefixed by vill refer to village market measurements. Variables
# prefixed by dis refer to district market measurements
prices <- select( CQSECCF, region=id_01, item_name, vill_unit=cm_f06meas,
vill_weight=cm_f06wght, vill_price=cm_f06pri, dis_unit = cm_f06meas2,
dis_weight=cm_f06wght2, dis_price=cm_f06pri2 )
# set some values to NA rather than zero, otherwise end up with strange values
# when converting units. Also it doesn't make sense when there is a weight but no
# price, or a price and no weight
prices$vill_weight[prices$vill_weight == 0] <- NA
prices$vill_price[prices$vill_price == 0] <- NA
prices$dis_weight[prices$dis_weight == 0] <- NA
prices$dis_price[prices$dis_price == 0] <- NA
# get unit prices - making sure to convert units into kilograms, i.e. price
# per kilogram.
prices$vill_price <- with( prices,
ifelse( vill_unit == "Grams", vill_price/( vill_weight/1000 ),
ifelse( vill_unit == "Kilograms", vill_price/( vill_weight ),
ifelse( vill_unit == "Litre", vill_price/( vill_weight ),
ifelse( vill_unit == "Millilitre", vill_price/( vill_weight/1000 ),
ifelse( vill_unit == "Pieces", vill_price/( vill_weight ),
vill_price/vill_weight ) ) ) ) ) )
prices$dis_price <- with( prices,
ifelse( dis_unit == "Grams", dis_price/( dis_weight/1000 ),
ifelse( dis_unit == "Kilograms", dis_price/( dis_weight ),
ifelse( dis_unit == "Litre", dis_price/( dis_weight ),
ifelse( dis_unit == "Millilitre", dis_price/( dis_weight/1000 ),
ifelse( dis_unit == "Pieces", dis_price/( dis_weight ),
dis_price/dis_weight ) ) ) ) ) )
# don't need original prices anymore, just local and district level unit prices
prices <- select( prices, region, item_name, vill_price, dis_price )
# test to see if each item is available for each region
test <- unique( select(prices, region, item_name) )
test_split <- split(test, test$region)
test_split_result <- sapply(test_split, function(elt) unique(test$item_name) %in% elt$item_name)
table(test_split_result)
# need to make sure there is a price observation for every item for every region
prices <- left_join( unique( select(prices, region, item_name) ), prices)
# a final thing. whoever imputed the data for year seriously does not understand
# white space. The item_name variable is all messed up. following code fixes this
x <- strsplit( as.character(prices$item_name) , "  " )
prices$item_name <- factor( sapply( x, function( elt ) return( elt[[1]] ) ) )
write.csv( prices, "M:/TZAYG/data/2012/prices_w3.csv", row.names = FALSE )
rm(list=ls())
setwd('M:/TZAYG/data/2012')
library(ggplot2)
library(plyr)
library(dplyr)
source("M:/TZAYG/functions/winsor.R")
# read in price data prepared earlier in
# TZA12_prep.R file and stored  in
# M:/cleaned_data/2012/prices.csv"
prices <- read.csv( "M:/TZAYG/data/2012/prices_w3.csv" )
# -----------BASIC ANALYSIS -----------
# # plotting functions
# plotpattern <- function( df, col ){
#         ggplot( df, aes_string( col ) ) + geom_histogram( fill='red', colour='black', binwidth=50 ) +
#                 labs( title=paste( as.character( df$item_name[1] ), 'price plot', sep=' ' ) ) +
#                 theme_bw(  )
# }
#
# quantile_plot <- function( x, y ){
#         qqplot( x, y, col = 'red', xlab = 'Theoretical Quantiles',
#                ylab = 'Sample Quantiles', main = 'qqplot' )
#
#         abline( a = 0, b = 1, col = 4 )
# }
#
# dens_plot <- function( x, breaks = 25, freq = FALSE ){
#         hist( x, breaks = breaks, col = 'lightgreen', freq = freq )
#         curve( dnorm( x, mean=mean( x ), sd=sd( x ) ), add=TRUE, col="darkblue", lwd=2 )
# }
#
# # use plotpattern function to search for outliers in the data in both the village
# # and district level prices. There are lots of outliers in pretty much all of the
# # food stuffs at both the village and the district level.
# d_ply(prices, .( item_name ), function( elt ) plotpattern( elt, 'vill_price' ), .print=TRUE )
# d_ply(prices, .( item_name ), function( elt ) plotpattern( elt, 'dis_price' ), .print=TRUE )
#
# # check out some basic stats of the local and district level prices
# range( prices$vill_price, na.rm=TRUE )
# summary( prices$vill_price )
#
# range( prices$dis_price, na.rm=TRUE )
# summary( prices$dis_price )
#
# # make a quantile plot to see how the distribution of maize prices compares
# # to the normal distribution. Need to standardise the maize prices first.
# x <- rnorm( 289, mean=0, sd=1 )
# m <- filter( prices, item_name=='Maize (grain)' ) %>%
#         mutate( dis_price=( dis_price - mean(dis_price, na.rm=TRUE ) )/sd( dis_price, na.rm=TRUE ),
#                vill_price=( vill_price - mean( vill_price, na.rm=TRUE ) )/sd( vill_price, na.rm=TRUE ) )
#
# quantile_plot( x, m$vill_price ) # ouch
# quantile_plot( x, m$dis_price )  # double ouch
# winsor both price variables and check to see what they look like afterwards
# winsoring like this will skew the distribution to the right. Might want to
# ammend winsoring functions to overcome this!
prices_winsor <- ddply( prices, .( item_name ), function( elt ) winsor3( elt, c( 'vill_price', 'dis_price' ), multiple=3 ) )
# may also need to watch the maize prices, seems to be a lage number of
# observations that end up at the edge of the distribution suggesting that a
# better approach is needed.
# d_ply( prices_winsor, .( item_name ), function( elt ) plotpattern( elt, 'vill_price' ), .print=TRUE )
# d_ply( prices_winsor, .( item_name ), function( elt ) plotpattern( elt, 'dis_price' ), .print=TRUE )
#
# # check the winsored prices with a quantile plot
# m2 <- subset( prices_winsor, item_name=='Maize (grain)' ) %>%
#         mutate( vill_price=( vill_price - mean( vill_price, na.rm = TRUE ) )/sd( vill_price, na.rm = TRUE ),
#                dis_price=( dis_price - mean( dis_price, na.rm = TRUE ) )/sd( dis_price, na.rm = TRUE ) )
#
# quantile_plot( x, m2$vill_price ) # much better
# quantile_plot( x, m2$dis_price )  # Also much better
#
# dens_plot( m2$vill_price, breaks = 20 ) # not bad
# dens_plot( m2$dis_price, breaks = 20 )  # Also not bad
#
#
# # ----------- FINAL PRICES ------------
# # For later analysis we need prices. Here two sets of prices are created from
# # the village and district prices by taking the average of each across regions
# # AND items. For example we might take the average of all Maize sold in village
# # markets in Dodoma. We also want to know the average ove the averages across
# # village and district level markets and the number of observations we have
# # to determine whether these prices are reliable or not
x <- unique(select(prices_winsor, region, item_name))
summary(x$region)
summary(x$item_name)
region_price <- ddply( prices_winsor, .( region, item_name ), summarize,
vill_price_region=mean( vill_price, na.rm = TRUE ),
dis_price_region=mean( dis_price, na.rm = TRUE ),
vill_obs_region=sum( is.na( vill_price ) ),
dis_obs_region=sum( is.na( dis_price ) ),
region_price=sum( vill_price_region,
dis_price_region, na.rm=TRUE )/2,
tot_obs=sum( vill_obs_region, dis_obs_region, na.rm=TRUE ) )
#' Analogous, to the regional prices, we may need national prices where the
#' regional observations are too few to be reliable. Here we calculate national
#' averages of the village and district prices and also the average of the
#' village and district averages. No need for observations because ultimately
#' the national prices will replace any regional prices which are not reliable
#' and will always have at least as many observations as the regional price
national_price <- ddply( prices, .( item_name ), summarize,
vill_price_national=mean( vill_price, na.rm=TRUE ),
dis_price_national=mean( dis_price, na.rm=TRUE ),
national_price=sum( vill_price_national,
dis_price_national,
na.rm=TRUE )/2 )
region_price$region_price[region_price$tot_obs < 5] <- NA
region_price <- left_join( region_price, national_price )
bad <- is.na( region_price$region_price )
region_price$region_price[bad] <- region_price$national_price[bad]
x <- unique(select(region_price, region, item_name))
summary(x$region)
summary(x$item_name)
write.csv( region_price,"M:/TZAYG/data/2012/prices_clean_w3.csv", row.names = FALSE )
rm(list=ls())
library( foreign )
library( plyr )
library( dplyr )
filepath <- "W:/LEI/Internationaal Beleid  (IB)/Projecten/2285000066 Africa Maize Yield Gap/SurveyData/Tanzania/2012/Data/"
setwd( filepath )
# read in prices
prices <- read.csv( "M:/cleaned_data/2012/prices_clean_y3.csv" ) %>%
select( region, item_name, region_price )
# read in region to match up with price regions
regions <- read.spss( "HH_SEC_A.SAV", to.data.frame=TRUE ) %>%
select( y3_hhid, region=hh_a01_1 )
# read in output
output <- read.csv( "M:/cleaned_data/2012/plot_output_y3.csv" )
# read in crop codes because itemnames in each year are different
crop_codes <- read.csv( "M:/cleaned_data/crop_code_y3.csv" )
# Need to have item_name, region variables in lower case to match up with crop
# name conversion table in crop_codes. Also one of the islands is spelt
# differently
levels( output$zaocode ) <- tolower( levels( output$zaocode ) )
levels( prices$region ) <- tolower( levels( prices$region ) )
levels( prices$item_name ) <- tolower( levels( prices$item_name ) )
levels( regions$region ) <- tolower( levels( regions$region ) )
levels( regions$region )[levels( regions$region )=="mjini/magharibi unguja"] <- "mjini magharibi"
# watch out for duplicates. There are two farmers who grow maize and beans on
# their fields and for some reason they have reported the beans as though they
# were two separate crops on the same plot.
# test <- ddply( output, .( y3_hhid, plotnum, zaocode ), function( elt ) nrow( elt ) )
# test[test$V1 %in% 2,]
# filter on only those plots that have maize on them and count the number of
# of crops per maize plot. Also filter out the plots where there is a duplicate
# as described above
by_plot <- group_by(output, y3_hhid, plotnum) %>%
filter(any(zaocode %in% "maize") & length(zaocode) == length(unique(zaocode))) %>%
summarise(crop_count=length(zaocode)) # 3077 plots once a couple of duplicates have been removed.
# merge together the output, region and cropcodes and the price data. Need
# crop codes because zaocodes in the output data and the item_name in the price
# data are different
output_maize <- left_join( by_plot, output )
output_maize <- left_join( output_maize, regions )
output_maize <- left_join( output_maize, crop_codes )
output_maize <- left_join( output_maize, prices )
summary(output_maize)
summary(prices$region)
rm(list=ls(0))
rm(list=ls())
library( foreign )
library( plyr )
library( dplyr )
filepath <- "W:/LEI/Internationaal Beleid  (IB)/Projecten/2285000066 Africa Maize Yield Gap/SurveyData/Tanzania/2012/Data/"
setwd( filepath )
# read in prices
prices <- read.csv( "M:/TZAYG/data/2012/prices_clean_w3.csv" ) %>%
select( region, item_name, region_price )
# read in region to match up with price regions
regions <- read.spss( "HH_SEC_A.SAV", to.data.frame=TRUE ) %>%
select( y3_hhid, region=hh_a01_1 )
# read in output
output <- read.csv( "M:/cleaned_data/2012/plot_output_y3.csv" )
# read in crop codes because itemnames in each year are different
crop_codes <- read.csv( "M:/cleaned_data/crop_code_y3.csv" )
# Need to have item_name, region variables in lower case to match up with crop
# name conversion table in crop_codes. Also one of the islands is spelt
# differently
levels( output$zaocode ) <- tolower( levels( output$zaocode ) )
levels( prices$region ) <- tolower( levels( prices$region ) )
levels( prices$item_name ) <- tolower( levels( prices$item_name ) )
levels( regions$region ) <- tolower( levels( regions$region ) )
levels( regions$region )[levels( regions$region )=="mjini/magharibi unguja"] <- "mjini magharibi"
# watch out for duplicates. There are two farmers who grow maize and beans on
# their fields and for some reason they have reported the beans as though they
# were two separate crops on the same plot.
# test <- ddply( output, .( y3_hhid, plotnum, zaocode ), function( elt ) nrow( elt ) )
# test[test$V1 %in% 2,]
# filter on only those plots that have maize on them and count the number of
# of crops per maize plot. Also filter out the plots where there is a duplicate
# as described above
by_plot <- group_by(output, y3_hhid, plotnum) %>%
filter(any(zaocode %in% "maize") & length(zaocode) == length(unique(zaocode))) %>%
summarise(crop_count=length(zaocode)) # 3077 plots once a couple of duplicates have been removed.
# merge together the output, region and cropcodes and the price data. Need
# crop codes because zaocodes in the output data and the item_name in the price
# data are different
output_maize <- left_join( by_plot, output )
output_maize <- left_join( output_maize, regions )
output_maize <- left_join( output_maize, crop_codes )
output_maize <- left_join( output_maize, prices )
summary(output_maize)
head(output_maize[is.na(output_maize$region_price)])
head(output_maize[is.na(output_maize$region_price),])
output_maize[is.na(output_maize$region_price),]
unique(prices$item_name)
rm(list=ls())
library( foreign )
library( plyr )
library( dplyr )
filepath <- "W:/LEI/Internationaal Beleid  (IB)/Projecten/2285000066 Africa Maize Yield Gap/SurveyData/Tanzania/2012/Data/"
setwd( filepath )
# read in prices
prices <- read.csv( "M:/TZAYG/data/2012/prices_clean_w3.csv" ) %>%
select( region, item_name, region_price )
# read in region to match up with price regions
regions <- read.spss( "HH_SEC_A.SAV", to.data.frame=TRUE ) %>%
select( y3_hhid, region=hh_a01_1 )
# read in output
output <- read.csv( "M:/cleaned_data/2012/plot_output_y3.csv" )
# read in crop codes because itemnames in each year are different
crop_codes <- read.csv( "M:/cleaned_data/crop_code_y3.csv" )
crop_codes$item_name[crop_codes$zaocode=="bulrush millet"] <- "millet (grain)"
crop_codes$item_name[crop_codes$zaocode=="tobacco"] <- "mangoes"
# Need to have item_name, region variables in lower case to match up with crop
# name conversion table in crop_codes. Also one of the islands is spelt
# differently
levels( output$zaocode ) <- tolower( levels( output$zaocode ) )
levels( prices$region ) <- tolower( levels( prices$region ) )
levels( prices$item_name ) <- tolower( levels( prices$item_name ) )
levels( regions$region ) <- tolower( levels( regions$region ) )
levels( regions$region )[levels( regions$region )=="mjini/magharibi unguja"] <- "mjini magharibi"
# watch out for duplicates. There are two farmers who grow maize and beans on
# their fields and for some reason they have reported the beans as though they
# were two separate crops on the same plot.
# test <- ddply( output, .( y3_hhid, plotnum, zaocode ), function( elt ) nrow( elt ) )
# test[test$V1 %in% 2,]
# filter on only those plots that have maize on them and count the number of
# of crops per maize plot. Also filter out the plots where there is a duplicate
# as described above
by_plot <- group_by(output, y3_hhid, plotnum) %>%
filter(any(zaocode %in% "maize") & length(zaocode) == length(unique(zaocode))) %>%
summarise(crop_count=length(zaocode)) # 3077 plots once a couple of duplicates have been removed.
# merge together the output, region and cropcodes and the price data. Need
# crop codes because zaocodes in the output data and the item_name in the price
# data are different
output_maize <- left_join( by_plot, output )
output_maize <- left_join( output_maize, regions )
output_maize <- left_join( output_maize, crop_codes )
output_maize <- left_join( output_maize, prices )
summary(output_maize)
output_maize[is.na(output_maize$region_price),]
output_maize$value <- output_maize$region_price * output_maize$output_kg
# finally calculate the Lie Myres index
output_maize <- ddply(output_maize, .(y3_hhid, plotnum),
summarize, plot_value=sum(value),
maize_price=region_price[zaocode %in% "maize"],
maize_value=maize_price * output_kg[zaocode == "maize"],
output_kg_old=output_kg[zaocode == "maize"],
output_kg_new = plot_value/maize_price,
maize_share = maize_value/plot_value * 100, crop_count = unique(crop_count),
beans = any(zaocode == "beans"), cash_crop=any(cash_crop))
write.csv(output_maize, "M:/cleaned_data/output_index_y3.csv", row.names=FALSE)
rm(list=ls())
library( foreign )
library( plyr )
library( dplyr )
filepath <- "W:/LEI/Internationaal Beleid  (IB)/Projecten/2285000066 Africa Maize Yield Gap/SurveyData/Tanzania/2012/Data/"
setwd( filepath )
# read in prices
prices <- read.csv( "M:/TZAYG/data/2012/prices_clean_w3.csv" ) %>%
select( region, item_name, region_price )
# read in region to match up with price regions
regions <- read.spss( "HH_SEC_A.SAV", to.data.frame=TRUE ) %>%
select( y3_hhid, region=hh_a01_1 )
# read in output
output <- read.csv( "M:/cleaned_data/2012/plot_output_y3.csv" )
# read in crop codes because itemnames in each year are different
crop_codes <- read.csv( "M:/cleaned_data/crop_code_y3.csv" )
crop_codes$item_name[crop_codes$zaocode=="bulrush millet"] <- "millet (grain)"
crop_codes$item_name[crop_codes$zaocode=="tobacco"] <- "mangoes"
# Need to have item_name, region variables in lower case to match up with crop
# name conversion table in crop_codes. Also one of the islands is spelt
# differently
levels( output$zaocode ) <- tolower( levels( output$zaocode ) )
levels( prices$region ) <- tolower( levels( prices$region ) )
levels( prices$item_name ) <- tolower( levels( prices$item_name ) )
levels( regions$region ) <- tolower( levels( regions$region ) )
levels( regions$region )[levels( regions$region )=="mjini/magharibi unguja"] <- "mjini magharibi"
# watch out for duplicates. There are two farmers who grow maize and beans on
# their fields and for some reason they have reported the beans as though they
# were two separate crops on the same plot.
# test <- ddply( output, .( y3_hhid, plotnum, zaocode ), function( elt ) nrow( elt ) )
# test[test$V1 %in% 2,]
# filter on only those plots that have maize on them and count the number of
# of crops per maize plot. Also filter out the plots where there is a duplicate
# as described above
by_plot <- group_by(output, y3_hhid, plotnum) %>%
filter(any(zaocode %in% "maize") & length(zaocode) == length(unique(zaocode))) %>%
summarise(crop_count=length(zaocode)) # 3077 plots once a couple of duplicates have been removed.
# merge together the output, region and cropcodes and the price data. Need
# crop codes because zaocodes in the output data and the item_name in the price
# data are different
output_maize <- left_join( by_plot, output )
output_maize <- left_join( output_maize, regions )
output_maize <- left_join( output_maize, crop_codes )
output_maize <- left_join( output_maize, prices )
# get a value variable which is the value of each crop on the plot.
output_maize$value <- output_maize$region_price * output_maize$output_kg
# finally calculate the Lie Myres index
output_maize <- ddply(output_maize, .(y3_hhid, plotnum),
summarize, plot_value=sum(value),
maize_price=region_price[zaocode %in% "maize"],
maize_value=maize_price * output_kg[zaocode == "maize"],
output_kg_old=output_kg[zaocode == "maize"],
output_kg_new = plot_value/maize_price,
maize_share = maize_value/plot_value * 100, crop_count = unique(crop_count),
beans = any(zaocode == "beans"), cash_crop=any(cash_crop))
write.csv(output_maize, "M:/TZAYG/data/2012output_index_w3.csv", row.names=FALSE)
setwd("M:/TZAYG/data")
library(dplyr)
output_w3 <- read.csv("./2012/output_index_w3.csv")
rm(list=ls())
# -------------------------------------
#' Liu Meyeres calculation for third
#' wave of Tanzania panel (2012).
# -------------------------------------
library( foreign )
library( plyr )
library( dplyr )
filepath <- "W:/LEI/Internationaal Beleid  (IB)/Projecten/2285000066 Africa Maize Yield Gap/SurveyData/Tanzania/2012/Data/"
setwd( filepath )
# read in prices
prices <- read.csv( "M:/TZAYG/data/2012/prices_clean_w3.csv" ) %>%
select( region, item_name, region_price )
# read in region to match up with price regions
regions <- read.spss( "HH_SEC_A.SAV", to.data.frame=TRUE ) %>%
select( y3_hhid, region=hh_a01_1 )
# read in output
output <- read.csv( "M:/cleaned_data/2012/plot_output_y3.csv" )
# read in crop codes because itemnames in each year are different
crop_codes <- read.csv( "M:/cleaned_data/crop_code_y3.csv" )
crop_codes$item_name[crop_codes$zaocode=="bulrush millet"] <- "millet (grain)"
crop_codes$item_name[crop_codes$zaocode=="tobacco"] <- "mangoes"
# Need to have item_name, region variables in lower case to match up with crop
# name conversion table in crop_codes. Also one of the islands is spelt
# differently
levels( output$zaocode ) <- tolower( levels( output$zaocode ) )
levels( prices$region ) <- tolower( levels( prices$region ) )
levels( prices$item_name ) <- tolower( levels( prices$item_name ) )
levels( regions$region ) <- tolower( levels( regions$region ) )
levels( regions$region )[levels( regions$region )=="mjini/magharibi unguja"] <- "mjini magharibi"
# watch out for duplicates. There are two farmers who grow maize and beans on
# their fields and for some reason they have reported the beans as though they
# were two separate crops on the same plot.
# test <- ddply( output, .( y3_hhid, plotnum, zaocode ), function( elt ) nrow( elt ) )
# test[test$V1 %in% 2,]
# filter on only those plots that have maize on them and count the number of
# of crops per maize plot. Also filter out the plots where there is a duplicate
# as described above
by_plot <- group_by(output, y3_hhid, plotnum) %>%
filter(any(zaocode %in% "maize") & length(zaocode) == length(unique(zaocode))) %>%
summarise(crop_count=length(zaocode)) # 3077 plots once a couple of duplicates have been removed.
# merge together the output, region and cropcodes and the price data. Need
# crop codes because zaocodes in the output data and the item_name in the price
# data are different
output_maize <- left_join( by_plot, output )
output_maize <- left_join( output_maize, regions )
output_maize <- left_join( output_maize, crop_codes )
output_maize <- left_join( output_maize, prices )
# get a value variable which is the value of each crop on the plot.
output_maize$value <- output_maize$region_price * output_maize$output_kg
# finally calculate the Lie Myres index
output_maize <- ddply(output_maize, .(y3_hhid, plotnum),
summarize, plot_value=sum(value),
maize_price=region_price[zaocode %in% "maize"],
maize_value=maize_price * output_kg[zaocode == "maize"],
output_kg_old=output_kg[zaocode == "maize"],
output_kg_new = plot_value/maize_price,
maize_share = maize_value/plot_value * 100, crop_count = unique(crop_count),
beans = any(zaocode == "beans"), cash_crop=any(cash_crop))
# save output
# write.csv(output_maize, "M:/TZAYG/data/2012/output_index_w3.csv", row.names=FALSE)
write.csv(output_maize, "M:/TZAYG/data/2012/output_index_w3.csv", row.names=FALSE)
rm(list=ls())
setwd("M:/TZAYG/data")
library(dplyr)
output_w3 <- read.csv("./2012/output_index_w3.csv")
# next up get the plot variables
plot_vars_w3 <- read.csv("./2012/plot_variables_w3.csv")
# now grab the area variables
areas_w3 <- read.csv("./2012/areas_w3.csv")
# and finally get the household information
HH_info_w3 <- read.csv("./2012/HH_total_w3.csv")
# now join everything together
panel_wave3 <- left_join(output_w3, plot_vars_w3)
panel_wave3 <- left_join(panel_wave3, areas_w3)
panel_wave3 <- left_join(panel_wave3, HH_info_w3)
q()
